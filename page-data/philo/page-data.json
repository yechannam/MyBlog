{"componentChunkName":"component---src-templates-post-template-tsx","path":"/philo/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h2>📖 글을 시작하며</h2>\n<p>42seoul의 프로젝트(과제) 중 하나인\nphilosopher를 정리한 글입니다.</p>\n<hr>\n<h2>📕 philosopher 소개</h2>\n<p>philosopher는 철학자들에게 밥을 먹이는 문제이다.</p>\n<p>모든 철학자는 둥근 책상에 둘러 앉아있고\n각 철학자 사이에는 포크가 <strong>1개</strong> 있다.\n책상의 중앙에는 스파게티가 있는데\n철학자가 스파게티를 먹으려면 <strong>2개</strong>의 포크를 집어야 한다.</p>\n<p>예를들어 5명의 철학자가 있다면\n포크도 5개밖에 없기 때문에\n모든 철학자가 동시에 스파게티를 먹진 못한다.</p>\n<p>적절히 스파게티를 먹도록 해\n철학자들이 최대한 죽지 않도록 해야한다.</p>\n<p>철학자들은 다음과 같은 순서로 행동한다.</p>\n<blockquote>\n<ol>\n<li>포크를 든다</li>\n<li>(2개의 포크를 들었으면) 먹는다</li>\n<li>잔다</li>\n<li>생각한다.</li>\n</ol>\n</blockquote>\n<p>만약 죽는 시간보다 마지막으로 먹기 시작했을 때부터의 시간이\n길다면 해당 철학자는 죽게되고 프로그램은 종료된다.</p>\n<p>프로그램의 인자로는\n철학자 수, 죽는 시간, 먹는 시간, 자는 시간, (선택)먹어야하는 횟수\n를 받는다.</p>\n<hr>\n<h2>📚 프로젝트에서 배운 것</h2>\n<h3>1. 스레드(thread)</h3>\n<p>그 동안의 42 프로젝트에서는 하나의 프로세스에서 <strong>하나의 스레드</strong>로만\n진행되는 프로그램(또는 함수)를 제작해왔다.</p>\n<p>이번 ‘philosopher’ 프로젝트에서는\n각 철학자들이 먹고 자는 등의 행동을 각자 해야했기 때문에\n철학자 한 명당 하나의 스레드를 할당해 줘야 했다.</p>\n<p>스레드 생성은 pthread_create 함수로 다음과 같은 방법으로 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token function\">pthread_create</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>philo<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>thread<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> thread_ing<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>philo<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span></code></pre></div>\n<p>첫번째는 pthread_t 구조체,\n세번째는 스레드를 만들고 처음 실행할 함수,\n마지막은 그 함수에 넘겨줄 데이터이다.</p>\n<p>pthread_create 함수는 스레드 생성을 성공하면 0을 반환한다.\n여기서 고민이 하나 생겼었다.</p>\n<p>스레드 생성 자원이 부족하거나 너무 많은 스레드를 생성하는 등\n스레드 생성을 실패하는 경우가 존재한다.\n그렇다면 이런 경우에는 어떻게 해 줘야할까?</p>\n<p>주변 사람들에게도 물어보고 인터넷도 찾아보며 나름대로 생각해본 결과\n내가 생각한 정답은 <strong>‘그때 그때 다르다’</strong> 였다.</p>\n<p>네이버 같은 웹에서 스레드 생성을 하나 실패했다고\n웹 전체를 내려버리면 안되기 때문에\n이런 경우에는 다시 스레드 생성을 시도하는 등 적절한 처리가 필요하다.</p>\n<p>하지만 이 프로그램은 하나의 철학자라도 없으면\n정상적으로 작동할 수 없기 때문에\n하나라도 스레드 생성에 실패할 경우\n프로그램이 종료되는 것이 맞다고 생각했다.</p>\n<p>따라서 다음과 같이</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> philo<span class=\"token operator\">-></span>info<span class=\"token punctuation\">.</span>philo_num<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">pthread_create</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>philo<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>thread<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> thread_ing<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>philo<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">&lt;</span> i<span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token function\">pthread_detach</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>philo<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>thread<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\tj<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\t<span class=\"token keyword\">return</span> <span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\ti<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>중간에 스레드 생성에 실패할 경우,\n그 전에 생성된 스레드를 회수하고 종료하도록 설계했다.</p>\n<p>이 부분에서 에러처리에 대한 고민을 해봤다.\nmalloc의 null가드를 해야할까?부터 시작해\n에러 처리를 어느 정도까지 해야할까? (printf같은 함수들도 해야하나?) 등에 대해 고민해보았다.</p>\n<p>내가 내린 결론은 최대한 <strong>관리하자</strong> 였다.</p>\n<p>요즘 컴퓨터 사양에 이정도 프로그램 돌리는데 오류가 날까 싶기도 하지만</p>\n<p>이런 처리를 안 했을 때 생길 수 있는 문제들을 생각해보면 해주는 것이 나은 것 같다.</p>\n<blockquote>\n<p><em>pthread_join</em>, <em>pthread_detach</em>의 차이</p>\n</blockquote>\n<blockquote>\n<p>-> 두 함수 모두 스레드의 자원을 회수하는데 사용된다. 차이점은 pthread_join은 스레드가 종료될까지 <strong>기다린다</strong>.</p>\n</blockquote>\n<blockquote>\n<p>ptread_detach를 사용하면 기다리지 않고 계속 실행된다. 따라서 메인 함수가 종료된다면 해당 스레드가 아직 실행중이더라도 바로 프로그램이 끝난다.</p>\n</blockquote>\n<h3>2. 뮤텍스(mutex)</h3>\n<p>뮤텍스는 공유 자원을 관리하기 위한 기법이다.\n이 프로젝트에서는 <strong>하나의 포크</strong>를 <strong>두명의 철학자</strong>가 공유한다.\n두 명이 동시에 한 개의 포크를 드는 것은 불가능 하므로\n포크를 뮤텍스로 지정해 한 포크는 한명만 들 수 있도록 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token function\">pthread_mutex_init</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>data<span class=\"token operator\">-></span>fork<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">pthread_mutex_destroy</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>data<span class=\"token operator\">-></span>fork<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">pthread_mutex_lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>data<span class=\"token operator\">-></span>fork<span class=\"token punctuation\">[</span>philo<span class=\"token operator\">-></span>right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">pthread_mutex_unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>data<span class=\"token operator\">-></span>fork<span class=\"token punctuation\">[</span>philo<span class=\"token operator\">-></span>right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>init은 뮤텍스를 할당하는 함수이다.\npthread_create 함수와 마찬가지로 성공시 0을 반환한다.\n(실패할 시 그때의 index를 받아 그 전까지 free(destroy)해줬다)</p>\n<p>destroy는 할당된 뮤텍스를 해제해준다.</p>\n<p>lock은 뮤텍스를 획득한다. 만약 해당 뮤텍스를 이미 다른 스레드에서 획득했다면 unlock될 때까지 대기한다.\nunlock은 획득했던 해당 뮤텍스를 해제한다.</p>\n<p>끝! 인줄 알았으나,,,</p>\n<p>프로젝트에 이런 글이 있다.</p>\n<blockquote>\n<p>데이터 레이스가 일어나면 절대 안됩니다.</p>\n</blockquote>\n<p>데이터 레이스는 컴파일 옵션에</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token parameter variable\">-g</span> <span class=\"token parameter variable\">-fsanitize</span><span class=\"token operator\">=</span>thread</code></pre></div>\n<p>를 넣으면 확인 할 수 있다.</p>\n<p>포크만 뮤텍스 처리를 하고 프로그램을 위 옵션을 넣고 돌려보니\n굉장히 많은 data race가 일어났다.</p>\n<p>이유는 ‘여러 스레드가 같은 공유자원에 <strong>동시에</strong> 접근 하려고 했기’ 때문이다.</p>\n<p>내 코드에서는 철학자의 죽음을 확인하기 위해 flag를 썼다.\n모든 철학자 스레드는 flag != 1일 때만 돌아가도록 했기 때문에 모든 스레드에서 flag라는 공유자원을 사용한다.\n이런 곳에서 데이터 레이스가 굉장히 많이 일어났던 것이다.</p>\n<p>flag외에도 main thread와 공유하는 자원들이 있었기 때문에\n모든 공유자원에 mutex를 생성해 데이터 레이스가 일어나는 것을 방지했다.</p>\n<p>나는 단순하게\n‘철학자가 포크 동시에 안들면 끝 아닌가?’\n라고 단순하게 생각했는데</p>\n<p>flag 등도 컴퓨터에겐 포크와 동일한 ‘공유 자원’ 이었던 것이다.</p>\n<p>당연한건데 왜 생각을 못했을까…</p>\n<h3>3. gettimeofday</h3>\n<p>현재 시간을 구할 수 있는 함수이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">\n<span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span>\t<span class=\"token function\">ft_gettime</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">timeval</span>\ttime<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span>\t\tnow<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token function\">gettimeofday</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>time<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tnow <span class=\"token operator\">=</span> time<span class=\"token punctuation\">.</span>tv_sec <span class=\"token operator\">*</span> <span class=\"token number\">1000</span> <span class=\"token operator\">+</span> time<span class=\"token punctuation\">.</span>tv_usec <span class=\"token operator\">*</span> <span class=\"token number\">0.001</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>now<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>이번 프로젝트에서는 단위가 ms이기 때문에 단위를 맞춰줬다.</p>\n<h3>4. 시간 밀림</h3>\n<p>철학자들이 굉장히 많이 생성되면 스레드간 Context Switching으로 시간이 밀리게 된다.\n어떻게 잘 하면 이를 더 잘 방지하는 방법이 있을 것 같긴 한데\n결국 Context Switching으로 인한 시간밀림은 불가피하다고 생각해\nusleep을 쪼개서 사용하는 것으로 만족했다.</p>\n<p>usleep에게 주는 값이 클 수록 시간 차가 많이 날 수 있기 때문에</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>실제 지난 시간 <span class=\"token operator\">&lt;=</span> 지나야하는 시간<span class=\"token punctuation\">)</span>\n\t<span class=\"token function\">usleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이런 식으로 작은 단위로 usleep을 시켜줬다.</p>\n<p>그런데 이 때 너무 작은 값으로 쪼개면 스레드가 많을 경우\n연산이 너무 많아져 Context Switching으로 인한 시간밀림이 심해질 수 있어\n적절한 값을 줘야했다.</p>\n<h3>5. 철학자야 밥먹자</h3>\n<p>철학자들 모두가 동시에 밥을 먹을 수 없기 때문에 굶어 죽는 철학자가 최대한 생기지 않도록 적절하게 처리해 줘야한다.</p>\n<p>굶음을 방지하기 위한 여러 방법이 있지만 나는 짝수와 홀수로 나누는 방법을 선택했다.</p>\n<ol>\n<li>짝수 철학자들은 왼쪽, 홀수 철학자들은 오른쪽을 먼저 집도록 했다.</li>\n</ol>\n<p>이렇게 하면 한쪽 포크를 들고 계속해서 놓지 않는 경우를 방지 할 수 있다.</p>\n<p>예) 철학자가 2명인 경우 1번 철학자는 1번 포크, 2번 철학자는 2번 포크를 들고 놓지 않고 있는 경우</p>\n<ol start=\"2\">\n<li>홀수 철학자들은 ‘잠깐’ 대기하고 포크를 잡도록 했다.</li>\n</ol>\n<p>이렇게 하지 않으면 짝수 철학자와 홀수 철학자가 포크를 잡기위해 경쟁을 하게된다. 최대한 굶음을 방지하기 위해서는 (철학자의 총 수가 짝수일 경우) 짝수만 먹고, 홀수만 먹고 를 반복해야하는데, 경쟁을 하게 되면 짝수와 홀수 철학자가 섞여 먹을 가능성이 생긴다.</p>\n<p>예외로 1명일 때는 포크가 1개밖에 없기 때문에 절대 식사를 하지 못한다.\n따라서 포크를 하나 잡고 대기하다가 죽는 시간이 되면 죽도록 처리했다.</p>\n<h2>📕 프로젝트를 마치며</h2>\n<p>생각보다 이 과제를 하는데 시간이 많이 걸렸다.</p>\n<p>하지만 스레드나 뮤텍스, 데이터 레이스 등 새로운 지식을 익히고\n그 동안 별 생각 없이 해오던 에러 처리를 어떻게 할 것인지 깊게 고민해보며 (42서울에서의 널가드 등)\n여러 부분에서 발전한 것 같아 나름 유익한 시간이 되었던 것 같다.</p>\n<h2>✅ 평가</h2>\n<p>평가를 받으며 알게된 것들이 있다.</p>\n<p><strong>1. 뮤텍스 자체를 포크로 사용해도 될까?</strong></p>\n<p>평가표에 보면 포크는 value를 가지고 있고 이것을 확인하고 변경할 수 있어야 한다는 내용이 있다.\n그렇기에 뮤텍스 자체를 포크로 사용하면 안되고 따로 변수로 포크의 상태를 지정해야한다는 주장이 있다.</p>\n<p>나는 뮤텍스 구조체 내부에 뮤텍스의 상태를 나타내는 int형 변수가 있고, lock, unlock 함수로 이 변수를 변경할 수 있기 때문에 문제가 되지 않는다고 디펜스 했다.</p>\n<p>프로젝트 파일이나 평가표에 ‘뮤텍스 자체를 포크로 지정하면 안된다’ 는 내용이 없기 때문에 디펜스 영역이라고 생각한다.</p>\n<p>** 2. usleep을 얼마나 작게 나눌까?**</p>\n<p>위에 서술한 내용이다. usleep이 정확하지 않기 때문에\n보다 작은 단위로 나눠서 사용했다.</p>\n<p>작게 나눌 수록 정확도가 올라가지만 그만큼 연산이 많아져 Context Switching으로 인한 시간밀림이 심해진다.</p>\n<p>나는 100정도로 나눠줬었는데,\n한 평가자 분께서는 철학자의 수만큼 usleep을 나누셨다고 한다.\n스레드가 많을 수록 큰 값으로 나눠야하기 때문에 굉장히 좋은 방법이라는 생각이 들었다.</p>\n<p><strong>3. 정의되지 않은 행동</strong></p>\n<p>한 평가자께서 ‘포크를 잡을 수 있는데 잡지 않는 것은 정의되지 않은 행동이다.‘라는 말씀을 하셨다.</p>\n<p>예를들어, 포크를 2개 다 잡고 바로 식사를 할 수 있을 때 포크를 잡도록 처리한 분들이 있다. 이런 경우는 모두 <strong>정의되지 않은 행동</strong> 으로 잘못되었다는 주장이다.</p>\n<p>나는 일단 그렇게 처리하지 않아 짧게 이야기한 뒤 넘어갔는데\n만약 이런식으로 구현하신 분이라면 디펜스를 잘 준비하셔야 할 것 같다.</p>\n<p>개인적으로 나는 괜찮다는 입장이다. (프로젝트 파일에 나와있지 않은 내용이기 때문에 디펜스 영역)</p>\n<p><img src=\"https://velog.velcdn.com/images/yecn/post/c77b2621-60ae-46e9-b79d-f5ca7a4e53fe/image.png\" alt=\"\"></p>\n<p>보너스는 생략했다.</p>\n<p>드디어 Philosopher (진짜) 끝!! 💯</p>","frontmatter":{"title":"[42 seoul] 철학자야 밥먹자 (philosopher)","summary":"배고픈 철학자에게 스파게티를 먹이자. 공유자원, 뮤텍스 관리","date":"2023.05.07.","categories":["42seoul","philosopher","42 project"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAABYlAAAWJQFJUiTwAAADSUlEQVR42p1UaVMTQRDl/3lyI4f3SXnhhaiUpZQX3pYioILHR/2ihlMNRhRF0BywEjZiYS7UDbsJCQTCbJ7VzW4MIMFyql5Nz3b3m349XZuVTCZB+PSzH1avFTa/DTbf6zmk20vB/xpdPisiMxHQykISELrAQVsFVj1dgXxLLvIsObxnP1uDPEs2n/+GXEs28i05WP10Jdyqez7hiXfHsK61EBs71qO0rZgJy1/txPr2Uj6bKGlbxyhrL8GG9jJs6CjjPI8mzyc89q4KhS35HLilcxPuDDTi0ZeHfMG2F1uw69UOBl1Sbt3J3+gCupDy5KUIi1uLsLdrN57Ij5m8uuc46hw3ccN+DbV959HgqscDqRlnems4dllCUyL1iKRRtdtfbk3tVBlhc+fGf6vQDCAysnOfZ6OgJY+TyabepvdxecltRTj6tpJl0/nsxzM4YNvPRDUfTqGy+wiKWgtSSjISUiAlXv18mXtGL39fauIHutB3DvcG7+K+1Ix9XXtS/ctM2FLAzqq3lbjy6RLqnbdZFlX28vsLTj75vhqX+mt59kgN+TMSUr9O9lTjuv0azvedw8X+WtQ5b3F1tf0XUO+sQ3XPCey2luOArWLpCo8bPaRmU/CR7kN8e7PUhJre0yyx0dXAF9ALk5+U0HBTnmcpQpp8IqXpJ0IaH3Pgqb+kgGzyE6hCUraowsruw8h5tpYr4eCWQg7kc5qd8hsxBBonWR2eI+S/DZL4OuGBS3XCEXLArtgxqA3ApbrgGneyPUC2AYdiZ9B3KTwIR8iOWCL2h1DXdShjIYx5f0DEBSCAwGgQkfEJRNUYvCM+KMEQwkqEgQQwOzUL/2gQ3+RRxLRJJiMuJqQVCAYhfRmCMh6CGtYwKElwyzK+e73w+nzwBwKQPR4MuYfZr2oaPCMjHPdLURYTyrIHqqrhf5fJk2X+sf3+AGKTc6XrRhsYht8EffvbeVGF5tKFQJKCDEIYthAiIxZVGIlEMDUVx7SuIy4EpoVAQtcRTiQwJUSqgkyY98phVYVPVfFG09ChKPigaejVwmyHZhIcLCh2AZIL+piSzPJM+Qv3ZVZ6H1OSKTmaSGAoGsVwNAp32j5k7AshTUwgGI/P9dkg/A3wsyWnWCiqrwAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/dc8de9b86781dc9688913209deef440c/bcee8/philo.png","srcSet":"/static/dc8de9b86781dc9688913209deef440c/21f2e/philo.png 112w,\n/static/dc8de9b86781dc9688913209deef440c/a3c63/philo.png 224w,\n/static/dc8de9b86781dc9688913209deef440c/bcee8/philo.png 448w","sizes":"(min-width: 448px) 448px, 100vw"},"sources":[{"srcSet":"/static/dc8de9b86781dc9688913209deef440c/8112f/philo.webp 112w,\n/static/dc8de9b86781dc9688913209deef440c/6d1c8/philo.webp 224w,\n/static/dc8de9b86781dc9688913209deef440c/9e2ae/philo.webp 448w","type":"image/webp","sizes":"(min-width: 448px) 448px, 100vw"}]},"width":448,"height":548}},"publicURL":"/static/dc8de9b86781dc9688913209deef440c/philo.png"}}}}]}},"pageContext":{"slug":"/philo/"}},"staticQueryHashes":[],"slicesMap":{}}